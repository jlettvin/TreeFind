# UniTree OverviewUniTree.py is a library class for building and using a fast lookup tree.It is a demonstration of a technique for rapid tests for presence ofa candidate word in a precompiled set.UniTree converts a list of words into a fast lookup tree on Unicode codepointsand provides a function for using that tree to lookup words.Words are added by an functor which allows dynamic updates,so that words can be added to the tree while it is in use.Words can be deleted and variants on words may lead to a canonical word.In threaded operation (other languages) this operation will need mutexes.See test_UniTree.py to see permitted operations on a UniTree.# FILES:```LICENSE                 Gnu V3.0README.md               This fileUniDigit.py             Class for converting digits between languagesUniTree.py              Class for treeing, pruning, and canonicalizing wordstest_UniTree.py         Unit tests (py.test and nose)```# Consider the words:```[hello, hi, hola, hold, hole, work, world]```# UniTree.py builds this dictionary tree structure (except with ords):```tree = {    u'h': {u'e': {u'l': {u'l': {u'o': {'$': set([u'hello'])}}}},           u'i': {'$': set([u'hi'])},           u'o': {u'l': {u'a': {'$': set([u'hola'])},                         u'd': {'$': set([u'hold'])},                         u'e': {'$': set([u'hole'])}}}},    u'w': {u'o': {u'r': {u'k': {'$': set([u'work'])},                         u'l': {u'd': {'$': set([u'world'])}}}}}}```# This simplified Python 2.7 code identifies treed words quickly:```def find(word, tree):    temp = tree    for c in list(word):        temp = temp.get(c, None)        if not temp:            break    return (temp and {} == temp.get('$', None)) or False```# FuturePerformance-----------It should be obvious that this is not highly efficient written in Python.This code, rewritten in C or C++ should be wicked fast.Maybe java could compete.Javascript JIT compiler may also do a good job.But the structure can be turned into indexing rather than hashingfor performance close to one or only a few Intel instructions per letter.Also, using unicode codepoints rather than letters is likely preferred.Parsing-------The functor is targeted for modification such thateach keyword is associated with a trigger functionwhich is installed in the tree structure at word terminals.For walking the parse tree after it is built,execution of those functions is an alternative to trigger execution.